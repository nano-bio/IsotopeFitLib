#include "IsotopeFitter.h"
//#include <matio.h>
//#include <stdint.h>

#include <fstream>
#include <chrono>
#include <iomanip>

using namespace std;

chrono::time_point<chrono::system_clock> timestart, timeend;
chrono::duration<double> elapsed;

int main(int argc, char** argv)
{
    setenv("GSL_IEEE_MODE", "double-precision,mask-underflow,mask-denormalized", 1);
    cout << getenv("GSL_IEEE_MODE") << endl;
    
    gsl_ieee_env_setup();
//    setprecision(15);
    
    timestart = chrono::system_clock::now();
    /* Load data from IFD file */
    string str = "/home/matlab/Michal/dev/IsotopeFitter/tests/testfileifd2.ifd";
    LoadIFDFile(str);
    
    /* Variable initializations */
    vector<double> Baseline, Signal, MassAxis;
    //double resPar0, resPar1;
    double resPar[3];   //matlab fits quadratic: 2-degree, but 3-order
    
    size_t dataLength = IFData::RawData[0].size();
    size_t moleculeCount = IFData::MoleculesData.size();
    
    Baseline.resize(dataLength);
    Signal.resize(dataLength);
    MassAxis.resize(dataLength);
    
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "start - end of init: " << elapsed.count() << endl;
    
    /* Background correction */
    timestart = chrono::system_clock::now();
    FitBaseline(IFData::BGCorrectionData.Bgm, IFData::BGCorrectionData.Bgy, IFData::RawData[0], Baseline);
        
    /* Actual subtraction of the baseline */
    //TODO: this can be done inside the baseline function
    for (int i = 0; i < Signal.size(); i++)
    {
        Signal[i] = IFData::RawData[1][i] - Baseline[i];
    }
    
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "baseline fit with subtraction " << elapsed.count() << endl;

    /* Mass offset correction */
    timestart = chrono::system_clock::now();
    FitMassOffsets(IFData::CalibrationData.COMList, IFData::CalibrationData.MassOffsetList, 0, IFData::RawData[0], MassAxis);
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "fit mass offset " << elapsed.count() << endl;
    
    /* Resolution fit */
    timestart = chrono::system_clock::now();
    FitResolution(IFData::CalibrationData.COMList, IFData::CalibrationData.ResolutionList, 0, resPar[0], resPar[1], resPar[2]);
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "fit resolution " << elapsed.count() << endl;
    
//    ofstream ofstr;
//    ofstr.open("newmassoffsetfit");
//    
//    for(int i=0; i<dataLength; i++)
//    {
//        ofstr << IFData::RawData[0][i] << " " << IFData::RawData[1][i] << " " << MassAxis[i] << " " << IFData::RawData[1][i] << endl;
//    }
//    ofstr.close();
    
    /* Design matrix initialization */
    timestart = chrono::system_clock::now();
    gsl_spmatrix *M = gsl_spmatrix_alloc(dataLength, moleculeCount);    
    
    gsl_spmatrix_set_zero(M);
    M = gsl_spmatrix_ccs(M);  //TODO: try also with crs
    
    /* Fitmask initialization */
    vector<bool> Fitmask;
    Fitmask.resize(dataLength);
    fill(Fitmask.begin(), Fitmask.end(), false);
    
    //TODO: why?
    double fwhmrange = 0.5;
    double searchrange = 1;
    
    /* Variables used in the loop */
    double mass, area, R, fwhm, idealSignalValue;
    vector<double> Breaks, BreaksRecalc;
    int peakLowerLimitIndex, peakUpperLimitIndex, fitmaskLowerLimitIndex, fitmaskUpperLimitIndex, breakIndex;
//    gsl_matrix *Coefs, *CoefsRecalc;
    
//    Breaks.resize(IFData::CalibrationData.Shape.Breaks.size());
//    Coefs.resize(IFData::CalibrationData.Shape.Coefs.size());
    
    Breaks = IFData::CalibrationData.Shape.Breaks;
    BreaksRecalc.resize(IFData::CalibrationData.Shape.Breaks.size());
    
//    Coefs = IFData::CalibrationData.Shape.Coefs;    
//    CoefsRecalc = IFData::CalibrationData.Shape.Coefs;  //easier than resizing the matrix
    //for_each(CoefsRecalc.begin(), CoefsRecalc.end(), vector.resize(IFData::CalibrationData.Shape.Coefs[0].size()));
    
    /* Load coefs into matrix */
    gsl_matrix *Coefs = gsl_matrix_alloc(IFData::CalibrationData.Shape.Coefs.size(), IFData::CalibrationData.Shape.Coefs[0].size());
    gsl_matrix *CoefsRecalc = gsl_matrix_alloc(IFData::CalibrationData.Shape.Coefs.size(), IFData::CalibrationData.Shape.Coefs[0].size());
    
    gsl_vector_view CoefsRow;
    
    for (int j=0; j<IFData::CalibrationData.Shape.Coefs.size(); j++)
    {
        for (int k=0; k<IFData::CalibrationData.Shape.Coefs[j].size(); k++)
        {
            gsl_matrix_set(Coefs, j, k, IFData::CalibrationData.Shape.Coefs[j][k]);
        }
    }
    
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "inits before molecule loop " << elapsed.count() << endl;
    
//    cout << "check" << endl;
    
    /* Loop through all molecules */
    timestart = chrono::system_clock::now();
    for (int i = 0; i < moleculeCount; i++) //moleculeCount
    {
        /* Loop through isotope peaks of current molecule */
        for (int j = 0; j < IFData::MoleculesData[i].PeakData.size(); j++)
        {
//            timestart = chrono::system_clock::now();
            mass = IFData::MoleculesData[i].PeakData[j][0];
            area = IFData::MoleculesData[i].PeakData[j][1];
            
            /* Calculate resolution of the line from resolution fit parameters, depending on its mass. 2 is hardcoded, because the fit is linear at the moment. */
            R = gsl_poly_eval(resPar, 2, mass);
            
            fwhm = mass / R;
            
//            cout << setprecision(15) << R << " " << fwhm << " " << mass << endl;
            
            if (fwhm < 0)
            {
                cout << "fwhm negative " << fwhm << endl;
            }
            
            /* Shape recalculation. This will go to the library later. */
            
            //transform(Breaks.begin(), Breaks.end(), Breaks.begin(), [](double x){return x * mass / R;});
            
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "molecule loop 1 " << elapsed.count() << endl;
            
//            timestart = chrono::system_clock::now();
            for(int k = 0; k < IFData::CalibrationData.Shape.Breaks.size(); k++)
            {
                BreaksRecalc[k] = Breaks[k] * fwhm + mass;
//                cout << setprecision(15) << k << " " << fwhm << " " << mass << " " << BreaksRecalc[k] << endl;
            }
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "breaksrecalc " << elapsed.count() << endl;
            
//            cout << IFData::CalibrationData.Shape.Coefs.size() << " " << IFData::CalibrationData.Shape.Coefs[0].size() << endl;
            
//            timestart = chrono::system_clock::now();
            for (int l = 0; l < IFData::CalibrationData.Shape.Coefs.size(); l++)
            {
//                cout << "check " << l << endl;
                for (int k=0; k<IFData::CalibrationData.Shape.Coefs[l].size(); k++)
                {                    
                    switch(k % 4)
                    {
                        case 0 :
                        {
//                            cout << l << " " << k << " " << gsl_matrix_get(Coefs, l, k) << " "  << gsl_pow_3(fwhm) << endl;
                            gsl_matrix_set(CoefsRecalc, l, k, gsl_matrix_get(Coefs, l, k) / gsl_pow_3(fwhm));
//                            cout << l << " " << k << " " << gsl_matrix_get(CoefsRecalc, l, k) << endl;
//                            cout << gsl_matrix_get(CoefsRecalc, l, k) << " ";
                            break;
                        }
                        case 1 :
                        {
//                            cout << l << " " << k << " " << gsl_matrix_get(Coefs, l, k) << " "  << gsl_pow_2(fwhm) << endl;
                            gsl_matrix_set(CoefsRecalc, l, k, gsl_matrix_get(Coefs, l, k) / gsl_pow_2(fwhm));
//                            cout << l << " " << k << " " << gsl_matrix_get(CoefsRecalc, l, k) << endl;
//                            cout << gsl_matrix_get(CoefsRecalc, l, k) << " ";
                            break;
                        }
                        case 2 :
                        {
//                            cout << l << " " << k << " " << gsl_matrix_get(Coefs, l, k) << " " << fwhm << endl;
                            gsl_matrix_set(CoefsRecalc, l, k, gsl_matrix_get(Coefs, l, k) / fwhm);
//                            cout << l << " " << k << " " << gsl_matrix_get(CoefsRecalc, l, k) << endl;
//                            cout << gsl_matrix_get(CoefsRecalc, l, k) << " ";
                            break;
                        }
                        case 3 :
                        {
//                            cout << l << " " << k << " " << gsl_matrix_get(Coefs, l, k) << endl;
                            gsl_matrix_set(CoefsRecalc, l, k, gsl_matrix_get(Coefs, l, k));
//                            cout << l << " " << k << " " << gsl_matrix_get(CoefsRecalc, l, k) << endl;
//                            cout << gsl_matrix_get(CoefsRecalc, l, k) << endl;
                            break;
                        }
                    }
                    
                    /* Area normalization */
                    gsl_matrix_set(CoefsRecalc, l, k, gsl_matrix_get(CoefsRecalc, l, k) * area / fwhm);
//                    gsl_matrix_set(Coefs, l, k, CoefsRecalc);
                }                
            }
            
//            for (int l = 0; l < IFData::CalibrationData.Shape.Coefs.size(); l++)
//            {
//                for (int k=0; k<IFData::CalibrationData.Shape.Coefs[l].size(); k++)
//                { 
//                    cout << gsl_matrix_get(CoefsRecalc, l, k) << " ";
//                }
//                cout << endl;
//            }
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "coefsrecalc " << elapsed.count() << endl;
            
            /* find indices on the massaxis, where elements are within the range of breaks. Might be relocated elsewhere. */
//            timestart = chrono::system_clock::now();
            for(int k = 0; k < MassAxis.size(); k++)
            {
                if(MassAxis[k] < BreaksRecalc[0])
                {
                    peakLowerLimitIndex = k + 1;    //might actually be slightly outside the breaks range -> extrapolate or +1
                }
                else break;
            }                       
            
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "peakLowerLimitIndex " << elapsed.count() << endl;
            
//            timestart = chrono::system_clock::now();
            for(int k = MassAxis.size() - 1; k >= 0; k--)
            {
                if(MassAxis[k] > BreaksRecalc[BreaksRecalc.size() - 1])
                {
                    peakUpperLimitIndex = k - 1;
                }
                else 
                {
//                    cout << MassAxis[k] << " " << BreaksRecalc[BreaksRecalc.size() - 1] << " " << k << endl;
                    break;
                }
            }
            
//            for (int k = peakLowerLimitIndex; k <= peakUpperLimitIndex; k++)
//            {
//                cout << MassAxis[k] << endl;
//            }
            
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "peakUpperLimitIndex " << elapsed.count() << endl;
            
//            cout << peakLowerLimitIndex << " " << peakUpperLimitIndex << endl;
            
            /* find indices on the massaxis, where elements are within the search range. */
//            timestart = chrono::system_clock::now();
            for(int k = 0; k < MassAxis.size(); k++)
            {
                if(MassAxis[k] < mass - searchrange * fwhmrange * fwhm)
                {
                    fitmaskLowerLimitIndex = k + 1;
                }
                else break;
            }
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "fitmaskLowerLimitIndex " << elapsed.count() << endl;
            
//            timestart = chrono::system_clock::now();
            for(int k = MassAxis.size() - 1; k >= 0; k--)
            {
                if(MassAxis[k] > mass + searchrange * fwhmrange * fwhm)
                {
                    fitmaskUpperLimitIndex = k;
                }
                else break;
            }
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "fitmaskUpperLimitIndex " << elapsed.count() << endl;
            
//            cout << fitmaskLowerLimitIndex << " " << fitmaskUpperLimitIndex << endl;
            
            /* Adjust the fitmask. This is done cumulatively. */
//            timestart = chrono::system_clock::now();
//            for(int k = 0; k < Fitmask.size(); k++)
//            {
//                if(k >= fitmaskLowerLimitIndex && k <= fitmaskUpperLimitIndex)
//                {
//                    Fitmask[k] = true;
//                }
//            }
            
            for(int k = fitmaskLowerLimitIndex; k <= fitmaskUpperLimitIndex; k++)
            {
                Fitmask[k] = true;
            }
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "Fitmask " << elapsed.count() << endl;
            
            /* Build design matrix */
//            timestart = chrono::system_clock::now();
            //cout << moleculeCount << endl;
            gsl_spmatrix *M_temp = gsl_spmatrix_alloc(dataLength, moleculeCount);
            
            for(int k = peakLowerLimitIndex; k <= peakUpperLimitIndex; k++)
            {
                /* evaluate the peakshape partial polynomial at the k index of mass axis */
                breakIndex = 1; //it is ok to start at 1, because peakLowerLimitIndex it the index of break 0
                
                do
                {                    
                    if(MassAxis[k] < BreaksRecalc[breakIndex])
                    {
                        /* evaluate the correct partial polynomial */
                        CoefsRow = gsl_matrix_row(CoefsRecalc, breakIndex - 1);
                        
                        //double *hue = gsl_vector_ptr(&CoefsRow.vector, 0);
                        double hue[4];
                        
                        for(int l = 0; l < 4; l++)
                        {
                            hue[l] = gsl_vector_get(&CoefsRow.vector, l);
                        }
                        
//                        cout << hue[0] << " " << hue[1] << " " << hue[2] << " " << hue[3] << " " << MassAxis[k] << endl;
                        
                        reverse(std::begin(hue), std::end(hue));
                        
//                        cout << hue[0] << " " << hue[1] << " " << hue[2] << " " << hue[3] << " " << MassAxis[k] << endl;
                        
                        idealSignalValue = area * gsl_poly_eval(hue, 4, MassAxis[k] - BreaksRecalc[breakIndex - 1]);
                        break;
                    }
                    else
                    {
//                        if(breakIndex == BreaksRecalc.size() - 1)   //segfault protection, for the last peakshape segment
//                        {
//                            CoefsRow = gsl_matrix_row(CoefsRecalc, breakIndex - 1);
//                        
//                            idealSignalValue = gsl_poly_eval(gsl_vector_ptr(&CoefsRow.vector, 0), 4, MassAxis[k]);
//                            break;
//                        }
//                        else
//                        {
//                            breakIndex++;
//                        }

                        breakIndex++;
                    }
                }while(breakIndex < BreaksRecalc.size());
                
                /* set the partial design matrix */
                gsl_spmatrix_set(M_temp, k, i, idealSignalValue);
            }
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "build M_temp " << elapsed.count() << endl;
            
            /* add the partial matrix to the final one */
            //M_temp = gsl_spmatrix_ccs(M_temp);  //cant use the compression, because we need to change the elements later
//            gsl_spmatrix_add(M, M, M_temp);
            
//            timestart = chrono::system_clock::now();
//            for(int k = 0; k < dataLength; k++)
//            {
//                for(int l = 0; l < moleculeCount; l++)
//                {
////                    gsl_spmatrix_set(M, k, l, gsl_spmatrix_get(M, k, l) + gsl_spmatrix_get(M_temp, k, l));    //stupid
//                    //gsl_spmatrix_add(M, M, M_temp);
//                }
//            }
            
            /* apply fitmask to M_temp, using current fitmask indices as bounds. Not the entire fitmask array! It would result in excess data. */
            for (int k = 0; k <= dataLength; k++)
            {
                if(!Fitmask[k])
                {
                    gsl_spmatrix_set(M_temp, k, i, 0);
                    //TODO: check if they are not zeroes anyway
                }
            }
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "fitmask Mtemp " << elapsed.count() << endl;
            
//            timestart = chrono::system_clock::now();
            M_temp = gsl_spmatrix_ccs(M_temp);
            
//            ofstream mtemp;
//            mtemp.open("mtemp");
//            for(int k=0; k<dataLength; k++)
//            {
//                mtemp << MassAxis[k] << " " << gsl_spmatrix_get(M_temp, k, i) << endl;
//            }
//            mtemp.close();
            
            //cout << M_temp->size1 << " " << M_temp->size2 << " " << M->size1 << " " << M->size2 << endl;
            gsl_spmatrix_add(M, M, M_temp);
            
            gsl_spmatrix_free(M_temp);
//            timeend = chrono::system_clock::now();
//            elapsed = timeend-timestart;
//            cout << "reformat add free " << elapsed.count() << endl;
            
        }
    }
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "molecule loop " << elapsed.count() << endl;
    
    /* Apply fitmask to signal */
    timestart = chrono::system_clock::now();
    for (int i = 0; i < dataLength; i++)
    {
        if(!Fitmask[i])
        {
//            for(int j = 0; j < moleculeCount; j++)    //applying fitmask to design matrix is taken inside the molecule loop for optimisation purposes
//            {
//                gsl_spmatrix_set(M, i, j, 0);
//            }
            
            Signal[i] = 0;
        }
    }
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "apply fitmask " << elapsed.count() << endl;
    
    /* Solve the system */
    gsl_multilarge_linear_workspace *Wrk;
    Wrk = gsl_multilarge_linear_alloc(gsl_multilarge_linear_tsqr, moleculeCount);
    
    /* L curve */
    size_t nlcurve = 2000;
    gsl_vector *reg_param = gsl_vector_alloc(nlcurve);
    gsl_vector *resnorms = gsl_vector_alloc(nlcurve);
    gsl_vector *solutionnorms = gsl_vector_alloc(nlcurve);
    
    /* Reg matrix */
//    gsl_matrix *L = gsl_matrix_alloc(moleculeCount, moleculeCount);
//    
//    for (int i=0; i<moleculeCount; i++)
//    {
//        gsl_matrix_set(L, i, i, 1);
//    }
    gsl_vector *L = gsl_vector_alloc(moleculeCount);
    for (int i=0; i<moleculeCount; i++)
    {
        gsl_vector_set(L, i, 1);
    }
//    
//    /* W matrix */
//    gsl_matrix *W = gsl_matrix_alloc(moleculeCount, moleculeCount);
//    
//    for (int i=0; i<dataLength; i++)
//    {
//        gsl_matrix_set(W, i, i, 1);
//    }
    
    /* Recreate design matrix in triplet format. Stupid. */
    gsl_spmatrix *Mtriplet = gsl_spmatrix_alloc(dataLength, moleculeCount);
    
    timestart = chrono::system_clock::now();
    for (int i = 0; i < dataLength; i++)
    {
        for (int j = 0; j < moleculeCount; j++)
        {
            if(gsl_spmatrix_get(M, i, j) != 0)
            {
                gsl_spmatrix_set(Mtriplet, i, j, gsl_spmatrix_get(M, i, j));
            }
        }
    }
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "Mtriplet " << elapsed.count() << endl;
    
    /* Horrible. */
//    for (int i = 0; i < dataLength; i++)
//    {
//        if(!Fitmask[i])
//        {
//            for(int j = 0; j < moleculeCount; j++)    //applying fitmask to design matrix is taken inside the molecule loop for optimisation purposes
//            {
//                gsl_spmatrix_set(Mtriplet, i, j, 0);
//            }
//            
//            Signal[i] = 0;
//        }
//    }
    
    timestart = chrono::system_clock::now();
    gsl_matrix *Mdense = gsl_matrix_alloc(dataLength, moleculeCount);
    gsl_spmatrix_sp2d(Mdense, Mtriplet);
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "to dense " << elapsed.count() << endl;
    
    timestart = chrono::system_clock::now();
    gsl_vector *Signalgsl = gsl_vector_alloc(dataLength);
    for (int i = 0; i < dataLength; i++)
    {
        gsl_vector_set(Signalgsl, i, Signal[i]);
    }
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "copy signal " << elapsed.count() << endl;
    
    /* Add data to the linear solver workspace. This has to be done by pieces. */    
    
    gsl_matrix_view Msub;
    gsl_vector_view Sigsub;
    
//    gsl_vector_view yv = gsl_vector_subvector(y, 0, nr);
    
    int pieceIndex = 0;
    int rowsLeft = dataLength;
    
    /* Standard form */
    gsl_matrix *MdenseStd = gsl_matrix_alloc(dataLength, moleculeCount);
    gsl_vector *SignalgslStd = gsl_vector_alloc(dataLength);
    
    gsl_multilarge_linear_stdform1(L, Mdense, Signalgsl, MdenseStd, SignalgslStd, Wrk);
    
    do
    {
        timestart = chrono::system_clock::now();
        if(rowsLeft > 10000)
        {
            Msub = gsl_matrix_submatrix(MdenseStd, pieceIndex * 10000, 0, 10000, moleculeCount);
            Sigsub = gsl_vector_subvector(SignalgslStd, pieceIndex * 10000, 10000);
            
            gsl_multilarge_linear_accumulate(&Msub.matrix, &Sigsub.vector, Wrk);
            
            rowsLeft -= 10000;
        }
        else
        {
            Msub = gsl_matrix_submatrix(MdenseStd, pieceIndex * 10000, 0, rowsLeft, moleculeCount);
            Sigsub = gsl_vector_subvector(SignalgslStd, pieceIndex * 10000, rowsLeft);
            
            gsl_multilarge_linear_accumulate(&Msub.matrix, &Sigsub.vector, Wrk);
            
            rowsLeft = 0;
        }
        
        pieceIndex++;
        
        timeend = chrono::system_clock::now();
        elapsed = timeend-timestart;
        cout << "accumulate iteration " << elapsed.count() << endl;
    }while(rowsLeft > 0);        
    
    //L-curve?
    gsl_multilarge_linear_lcurve(reg_param, resnorms, solutionnorms, Wrk);  
    
    
    
    
    
//    ofstream lambda;
//    lambda.open("lambda");
//    for(int i=0; i < 2000; i++)
//    {
//        lambda << reg_param->data[i] << " " << resnorms->data[i] << " " << solutionnorms->data[i] << endl;
//    }
//    lambda.close();
    
    gsl_vector *S_calcStd = gsl_vector_alloc(moleculeCount);
    double rnorm, snorm, rcond;
    
    /* Solve the system */
    timestart = chrono::system_clock::now();
    int solres = gsl_multilarge_linear_solve(0, S_calcStd, &rnorm, &snorm, Wrk);
    //cout << "solve " << solres << endl;
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "solve " << elapsed.count() << endl;
    
    gsl_multilarge_linear_rcond(&rcond, Wrk);
    
    cout << "rnorm " << rnorm << endl;
    cout << "snorm " << snorm << endl;
//    cout << "rcond " << rcond << endl;
    printf("%E\n", rcond);
    
    /* Transform the solution back */
    gsl_vector *S_calc = gsl_vector_alloc(moleculeCount);
    gsl_multilarge_linear_genform1(L, S_calcStd, S_calc, Wrk);

    /* Calculate the fitted spectrum */
    gsl_vector *CalcSignal = gsl_vector_alloc(dataLength);
    
    timestart = chrono::system_clock::now();
    gsl_blas_dgemv(CblasNoTrans, 1, Mdense, S_calc, 0, CalcSignal);
    timeend = chrono::system_clock::now();
    elapsed = timeend-timestart;
    cout << "calc spectrum " << elapsed.count() << endl;
    
    ofstream calcSpec;
    calcSpec.open("calcSpec");
    
    for (int i = 0; i < dataLength; i++)
    {
        calcSpec << MassAxis[i] << " " << gsl_vector_get(CalcSignal, i) << " " << Signal[i] << endl;
    }
    calcSpec.close();
    
    return 0;
}

/* Code snippets */

//        ofstream stream;        
//        stream.open("rawexportcode");
//        
//        for (int i=0; i<IFData::RawData[0].size(); i++)
//        {
//            stream << IFData::RawData[0][i] << " " << IFData::RawData[1][i] << endl;
//        }
//        stream.close();

//try
//    {
//        throw 5;
//    }
//    catch (int h)
//    {
//        cerr << h << endl;
//    }

//    vector<double> *frgd = new vector<double>();
//    //vector<double> gg = *frgd;
//    
//    frgd->push_back(4);
//    
//    cout << frgd->at(0) << endl;
//    
//    delete frgd;

void PrintIFDFileContents()
{
    cout << "RawData" << endl;
    for (int i=0; i<10; i++)
    {
        cout << IFData::RawData[0][i] << " " << IFData::RawData[1][i] << " " << endl;
    }
    cout << endl;
    
    cout << "startInd" << endl;
    cout << IFData::startInd << endl;
    cout << endl;
    
    cout << "endInd" << endl;
    cout << IFData::endInd << endl;
    cout << endl;
    
    cout << "Molecules" << endl;
    for (int i=0; i<10; i++)
    {
        cout << "peak data" << endl;        
        for(int k = 0; k < IFData::MoleculesData[i].PeakData.size(); k++)
        {
            for(int l = 0; l < IFData::MoleculesData[i].PeakData[k].size(); l++)
            {
                cout << IFData::MoleculesData[i].PeakData[k][l] << " ";
            }
            cout << endl;
        }
        
        cout << "name " << IFData::MoleculesData[i].name << endl;
        cout << "minMass " << IFData::MoleculesData[i].minMass << endl;
        cout << "maxMass " << IFData::MoleculesData[i].maxMass << endl;
        cout << "com " << IFData::MoleculesData[i].com << endl;
        cout << "minInd " << IFData::MoleculesData[i].minInd << endl;
        cout << "maxInd " << IFData::MoleculesData[i].maxInd << endl;
        cout << "area " << IFData::MoleculesData[i].area << endl;
        cout << "areaError " << IFData::MoleculesData[i].areaError << endl;
        cout << "rootIndex " << IFData::MoleculesData[i].rootIndex << endl;
        cout << endl;
    }
    
    cout << "Calibration" << endl;

    cout << "comlist" << endl;
    for (int j=0; j<10; j++)
    {
        cout << IFData::CalibrationData.COMList[j] << endl;
    }

    cout << "MassOffsetList" << endl;
    for (int j=0; j<10; j++)
    {
        cout << IFData::CalibrationData.MassOffsetList[j] << endl;
    }

    cout << "ResolutionList" << endl;
    for (int j=0; j<10; j++)
    {
        cout << IFData::CalibrationData.ResolutionList[j] << endl;
    }
    cout << "MassOffsetMethod " << IFData::CalibrationData.MassOffsetMethod << endl;
    cout << "ResolutionMethod " << IFData::CalibrationData.ResolutionMethod << endl;
    cout << "massOffsetParam " << IFData::CalibrationData.massOffsetParam << endl;
    cout << "resolutionParam " << IFData::CalibrationData.resolutionParam << endl;
    cout << "NameList" << endl;
    for (int j=0; j<10; j++)
    {
        cout << IFData::CalibrationData.NameList[j] << endl;
    }
    cout << endl;
        
    cout << "Shape" << endl;
    cout << "form " << IFData::CalibrationData.Shape.form << endl;
    cout << "Breaks " << endl;
    for (int j=0; j<10; j++)
    {
        cout << IFData::CalibrationData.Shape.Breaks[j] << endl;
    }    
    cout << "Coefs " << endl;
    for (int j=0; j<IFData::CalibrationData.Shape.Coefs.size(); j++)
    {
        for (int k=0; k<IFData::CalibrationData.Shape.Coefs[j].size(); k++)
        {
            cout << IFData::CalibrationData.Shape.Coefs[j][k] << "\t";
        }
        cout << endl;
    }    
    cout << "pieces " << IFData::CalibrationData.Shape.pieces << endl;
    cout << "order " << IFData::CalibrationData.Shape.order << endl;    
    cout << "dim " << IFData::CalibrationData.Shape.dim << endl;
    cout << endl;

    cout << "bgcorrection " << endl;
    cout << "startMass " << IFData::BGCorrectionData.startMass << endl;
    cout << "endMass " << IFData::BGCorrectionData.endMass << endl;
    cout << "nDiv " << IFData::BGCorrectionData.nDiv << endl;
    cout << "percent " << IFData::BGCorrectionData.percent << endl;
    
    cout << "Bgm " << endl;
    for (int j=0; j<10; j++)
    {
        cout << IFData::BGCorrectionData.Bgm[j] << endl;
    }    
    cout << "Bgy " << endl;
    for (int j=0; j<10; j++)
    {
        cout << IFData::BGCorrectionData.Bgy[j] << endl;
    }    
    cout << endl;

    cout << "gui " << endl;
    for (int j=0; j<IFData::GUIStatus.size(); j++)
    {
        cout << IFData::GUIStatus[j] << endl;
    }    
    cout << endl;

    cout << "originalFileName " << IFData::FileInfoData.originalFileName << endl;
    cout << "fileName " << IFData::FileInfoData.fileName << endl;
    cout << "pathName " << IFData::FileInfoData.pathName << endl;
    cout << "h5CompletePath " << IFData::FileInfoData.h5CompletePath << endl;
    cout << endl;
}
